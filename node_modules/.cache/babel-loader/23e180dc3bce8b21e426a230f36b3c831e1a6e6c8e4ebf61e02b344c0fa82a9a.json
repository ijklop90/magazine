{"ast":null,"code":"import { EventEmitter } from 'events';\n/**\n * Wrapper around the Cloudflare built-in socket that can be used by the `Connection`.\n */\nexport class CloudflareSocket extends EventEmitter {\n  constructor(ssl) {\n    super();\n    this.ssl = ssl;\n    this.writable = false;\n    this.destroyed = false;\n    this._upgrading = false;\n    this._upgraded = false;\n    this._cfSocket = null;\n    this._cfWriter = null;\n    this._cfReader = null;\n  }\n  setNoDelay() {\n    return this;\n  }\n  setKeepAlive() {\n    return this;\n  }\n  ref() {\n    return this;\n  }\n  unref() {\n    return this;\n  }\n  async connect(port, host, connectListener) {\n    try {\n      log('connecting');\n      if (connectListener) this.once('connect', connectListener);\n      const options = this.ssl ? {\n        secureTransport: 'starttls'\n      } : {};\n      const {\n        connect\n      } = await import('cloudflare:sockets');\n      this._cfSocket = connect(`${host}:${port}`, options);\n      this._cfWriter = this._cfSocket.writable.getWriter();\n      this._addClosedHandler();\n      this._cfReader = this._cfSocket.readable.getReader();\n      if (this.ssl) {\n        this._listenOnce().catch(e => this.emit('error', e));\n      } else {\n        this._listen().catch(e => this.emit('error', e));\n      }\n      await this._cfWriter.ready;\n      log('socket ready');\n      this.writable = true;\n      this.emit('connect');\n      return this;\n    } catch (e) {\n      this.emit('error', e);\n    }\n  }\n  async _listen() {\n    while (true) {\n      log('awaiting receive from CF socket');\n      const {\n        done,\n        value\n      } = await this._cfReader.read();\n      log('CF socket received:', done, value);\n      if (done) {\n        log('done');\n        break;\n      }\n      this.emit('data', Buffer.from(value));\n    }\n  }\n  async _listenOnce() {\n    log('awaiting first receive from CF socket');\n    const {\n      done,\n      value\n    } = await this._cfReader.read();\n    log('First CF socket received:', done, value);\n    this.emit('data', Buffer.from(value));\n  }\n  write(data) {\n    let encoding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'utf8';\n    let callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : () => {};\n    if (data.length === 0) return callback();\n    if (typeof data === 'string') data = Buffer.from(data, encoding);\n    log('sending data direct:', data);\n    this._cfWriter.write(data).then(() => {\n      log('data sent');\n      callback();\n    }, err => {\n      log('send error', err);\n      callback(err);\n    });\n    return true;\n  }\n  end() {\n    let data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Buffer.alloc(0);\n    let encoding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'utf8';\n    let callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : () => {};\n    log('ending CF socket');\n    this.write(data, encoding, err => {\n      this._cfSocket.close();\n      if (callback) callback(err);\n    });\n    return this;\n  }\n  destroy(reason) {\n    log('destroying CF socket', reason);\n    this.destroyed = true;\n    return this.end();\n  }\n  startTls(options) {\n    if (this._upgraded) {\n      // Don't try to upgrade again.\n      this.emit('error', 'Cannot call `startTls()` more than once on a socket');\n      return;\n    }\n    this._cfWriter.releaseLock();\n    this._cfReader.releaseLock();\n    this._upgrading = true;\n    this._cfSocket = this._cfSocket.startTls(options);\n    this._cfWriter = this._cfSocket.writable.getWriter();\n    this._cfReader = this._cfSocket.readable.getReader();\n    this._addClosedHandler();\n    this._listen().catch(e => this.emit('error', e));\n  }\n  _addClosedHandler() {\n    this._cfSocket.closed.then(() => {\n      if (!this._upgrading) {\n        log('CF socket closed');\n        this._cfSocket = null;\n        this.emit('close');\n      } else {\n        this._upgrading = false;\n        this._upgraded = true;\n      }\n    }).catch(e => this.emit('error', e));\n  }\n}\nconst debug = false;\nfunction dump(data) {\n  if (data instanceof Uint8Array || data instanceof ArrayBuffer) {\n    const hex = Buffer.from(data).toString('hex');\n    const str = new TextDecoder().decode(data);\n    return `\\n>>> STR: \"${str.replace(/\\n/g, '\\\\n')}\"\\n>>> HEX: ${hex}\\n`;\n  } else {\n    return data;\n  }\n}\nfunction log() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n  debug && console.log(...args.map(dump));\n}","map":{"version":3,"names":["EventEmitter","CloudflareSocket","constructor","ssl","writable","destroyed","_upgrading","_upgraded","_cfSocket","_cfWriter","_cfReader","setNoDelay","setKeepAlive","ref","unref","connect","port","host","connectListener","log","once","options","secureTransport","getWriter","_addClosedHandler","readable","getReader","_listenOnce","catch","e","emit","_listen","ready","done","value","read","Buffer","from","write","data","encoding","arguments","length","undefined","callback","then","err","end","alloc","close","destroy","reason","startTls","releaseLock","closed","debug","dump","Uint8Array","ArrayBuffer","hex","toString","str","TextDecoder","decode","replace","_len","args","Array","_key","console","map"],"sources":["C:\\web\\diplom\\magazine\\node_modules\\pg-cloudflare\\src\\index.ts"],"sourcesContent":["import { SocketOptions, Socket, TlsOptions } from 'cloudflare:sockets'\nimport { EventEmitter } from 'events'\n\n/**\n * Wrapper around the Cloudflare built-in socket that can be used by the `Connection`.\n */\nexport class CloudflareSocket extends EventEmitter {\n  writable = false\n  destroyed = false\n\n  private _upgrading = false\n  private _upgraded = false\n  private _cfSocket: Socket | null = null\n  private _cfWriter: WritableStreamDefaultWriter | null = null\n  private _cfReader: ReadableStreamDefaultReader | null = null\n\n  constructor(readonly ssl: boolean) {\n    super()\n  }\n\n  setNoDelay() {\n    return this\n  }\n  setKeepAlive() {\n    return this\n  }\n  ref() {\n    return this\n  }\n  unref() {\n    return this\n  }\n\n  async connect(port: number, host: string, connectListener?: (...args: unknown[]) => void) {\n    try {\n      log('connecting')\n      if (connectListener) this.once('connect', connectListener)\n\n      const options: SocketOptions = this.ssl ? { secureTransport: 'starttls' } : {}\n      const { connect } = await import('cloudflare:sockets')\n      this._cfSocket = connect(`${host}:${port}`, options)\n      this._cfWriter = this._cfSocket.writable.getWriter()\n      this._addClosedHandler()\n\n      this._cfReader = this._cfSocket.readable.getReader()\n      if (this.ssl) {\n        this._listenOnce().catch((e) => this.emit('error', e))\n      } else {\n        this._listen().catch((e) => this.emit('error', e))\n      }\n\n      await this._cfWriter!.ready\n      log('socket ready')\n      this.writable = true\n      this.emit('connect')\n\n      return this\n    } catch (e) {\n      this.emit('error', e)\n    }\n  }\n\n  async _listen() {\n    while (true) {\n      log('awaiting receive from CF socket')\n      const { done, value } = await this._cfReader!.read()\n      log('CF socket received:', done, value)\n      if (done) {\n        log('done')\n        break\n      }\n      this.emit('data', Buffer.from(value))\n    }\n  }\n\n  async _listenOnce() {\n    log('awaiting first receive from CF socket')\n    const { done, value } = await this._cfReader!.read()\n    log('First CF socket received:', done, value)\n    this.emit('data', Buffer.from(value))\n  }\n\n  write(\n    data: Uint8Array | string,\n    encoding: BufferEncoding = 'utf8',\n    callback: (...args: unknown[]) => void = () => {}\n  ) {\n    if (data.length === 0) return callback()\n    if (typeof data === 'string') data = Buffer.from(data, encoding)\n\n    log('sending data direct:', data)\n    this._cfWriter!.write(data).then(\n      () => {\n        log('data sent')\n        callback()\n      },\n      (err) => {\n        log('send error', err)\n        callback(err)\n      }\n    )\n    return true\n  }\n\n  end(data = Buffer.alloc(0), encoding: BufferEncoding = 'utf8', callback: (...args: unknown[]) => void = () => {}) {\n    log('ending CF socket')\n    this.write(data, encoding, (err) => {\n      this._cfSocket!.close()\n      if (callback) callback(err)\n    })\n    return this\n  }\n\n  destroy(reason: string) {\n    log('destroying CF socket', reason)\n    this.destroyed = true\n    return this.end()\n  }\n\n  startTls(options: TlsOptions) {\n    if (this._upgraded) {\n      // Don't try to upgrade again.\n      this.emit('error', 'Cannot call `startTls()` more than once on a socket')\n      return\n    }\n    this._cfWriter!.releaseLock()\n    this._cfReader!.releaseLock()\n    this._upgrading = true\n    this._cfSocket = this._cfSocket!.startTls(options)\n    this._cfWriter = this._cfSocket.writable.getWriter()\n    this._cfReader = this._cfSocket.readable.getReader()\n    this._addClosedHandler()\n    this._listen().catch((e) => this.emit('error', e))\n  }\n\n  _addClosedHandler() {\n    this._cfSocket!.closed.then(() => {\n      if (!this._upgrading) {\n        log('CF socket closed')\n        this._cfSocket = null\n        this.emit('close')\n      } else {\n        this._upgrading = false\n        this._upgraded = true\n      }\n    }).catch((e) => this.emit('error', e))\n  }\n}\n\nconst debug = false\n\nfunction dump(data: unknown) {\n  if (data instanceof Uint8Array || data instanceof ArrayBuffer) {\n    const hex = Buffer.from(data).toString('hex')\n    const str = new TextDecoder().decode(data)\n    return `\\n>>> STR: \"${str.replace(/\\n/g, '\\\\n')}\"\\n>>> HEX: ${hex}\\n`\n  } else {\n    return data\n  }\n}\n\nfunction log(...args: unknown[]) {\n  debug && console.log(...args.map(dump))\n}\n"],"mappings":"AACA,SAASA,YAAY,QAAQ,QAAQ;AAErC;;;AAGA,OAAM,MAAOC,gBAAiB,SAAQD,YAAY;EAUhDE,YAAqBC,GAAY;IAC/B,KAAK,EAAE;IADY,KAAAA,GAAG,GAAHA,GAAG;IATxB,KAAAC,QAAQ,GAAG,KAAK;IAChB,KAAAC,SAAS,GAAG,KAAK;IAET,KAAAC,UAAU,GAAG,KAAK;IAClB,KAAAC,SAAS,GAAG,KAAK;IACjB,KAAAC,SAAS,GAAkB,IAAI;IAC/B,KAAAC,SAAS,GAAuC,IAAI;IACpD,KAAAC,SAAS,GAAuC,IAAI;EAI5D;EAEAC,UAAUA,CAAA;IACR,OAAO,IAAI;EACb;EACAC,YAAYA,CAAA;IACV,OAAO,IAAI;EACb;EACAC,GAAGA,CAAA;IACD,OAAO,IAAI;EACb;EACAC,KAAKA,CAAA;IACH,OAAO,IAAI;EACb;EAEA,MAAMC,OAAOA,CAACC,IAAY,EAAEC,IAAY,EAAEC,eAA8C;IACtF,IAAI;MACFC,GAAG,CAAC,YAAY,CAAC;MACjB,IAAID,eAAe,EAAE,IAAI,CAACE,IAAI,CAAC,SAAS,EAAEF,eAAe,CAAC;MAE1D,MAAMG,OAAO,GAAkB,IAAI,CAAClB,GAAG,GAAG;QAAEmB,eAAe,EAAE;MAAU,CAAE,GAAG,EAAE;MAC9E,MAAM;QAAEP;MAAO,CAAE,GAAG,MAAM,MAAM,CAAC,oBAAoB,CAAC;MACtD,IAAI,CAACP,SAAS,GAAGO,OAAO,CAAC,GAAGE,IAAI,IAAID,IAAI,EAAE,EAAEK,OAAO,CAAC;MACpD,IAAI,CAACZ,SAAS,GAAG,IAAI,CAACD,SAAS,CAACJ,QAAQ,CAACmB,SAAS,EAAE;MACpD,IAAI,CAACC,iBAAiB,EAAE;MAExB,IAAI,CAACd,SAAS,GAAG,IAAI,CAACF,SAAS,CAACiB,QAAQ,CAACC,SAAS,EAAE;MACpD,IAAI,IAAI,CAACvB,GAAG,EAAE;QACZ,IAAI,CAACwB,WAAW,EAAE,CAACC,KAAK,CAAEC,CAAC,IAAK,IAAI,CAACC,IAAI,CAAC,OAAO,EAAED,CAAC,CAAC,CAAC;OACvD,MAAM;QACL,IAAI,CAACE,OAAO,EAAE,CAACH,KAAK,CAAEC,CAAC,IAAK,IAAI,CAACC,IAAI,CAAC,OAAO,EAAED,CAAC,CAAC,CAAC;;MAGpD,MAAM,IAAI,CAACpB,SAAU,CAACuB,KAAK;MAC3Bb,GAAG,CAAC,cAAc,CAAC;MACnB,IAAI,CAACf,QAAQ,GAAG,IAAI;MACpB,IAAI,CAAC0B,IAAI,CAAC,SAAS,CAAC;MAEpB,OAAO,IAAI;KACZ,CAAC,OAAOD,CAAC,EAAE;MACV,IAAI,CAACC,IAAI,CAAC,OAAO,EAAED,CAAC,CAAC;;EAEzB;EAEA,MAAME,OAAOA,CAAA;IACX,OAAO,IAAI,EAAE;MACXZ,GAAG,CAAC,iCAAiC,CAAC;MACtC,MAAM;QAAEc,IAAI;QAAEC;MAAK,CAAE,GAAG,MAAM,IAAI,CAACxB,SAAU,CAACyB,IAAI,EAAE;MACpDhB,GAAG,CAAC,qBAAqB,EAAEc,IAAI,EAAEC,KAAK,CAAC;MACvC,IAAID,IAAI,EAAE;QACRd,GAAG,CAAC,MAAM,CAAC;QACX;;MAEF,IAAI,CAACW,IAAI,CAAC,MAAM,EAAEM,MAAM,CAACC,IAAI,CAACH,KAAK,CAAC,CAAC;;EAEzC;EAEA,MAAMP,WAAWA,CAAA;IACfR,GAAG,CAAC,uCAAuC,CAAC;IAC5C,MAAM;MAAEc,IAAI;MAAEC;IAAK,CAAE,GAAG,MAAM,IAAI,CAACxB,SAAU,CAACyB,IAAI,EAAE;IACpDhB,GAAG,CAAC,2BAA2B,EAAEc,IAAI,EAAEC,KAAK,CAAC;IAC7C,IAAI,CAACJ,IAAI,CAAC,MAAM,EAAEM,MAAM,CAACC,IAAI,CAACH,KAAK,CAAC,CAAC;EACvC;EAEAI,KAAKA,CACHC,IAAyB,EAEwB;IAAA,IADjDC,QAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAA2B,MAAM;IAAA,IACjCG,QAAA,GAAAH,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAyC,MAAK,CAAE,CAAC;IAEjD,IAAIF,IAAI,CAACG,MAAM,KAAK,CAAC,EAAE,OAAOE,QAAQ,EAAE;IACxC,IAAI,OAAOL,IAAI,KAAK,QAAQ,EAAEA,IAAI,GAAGH,MAAM,CAACC,IAAI,CAACE,IAAI,EAAEC,QAAQ,CAAC;IAEhErB,GAAG,CAAC,sBAAsB,EAAEoB,IAAI,CAAC;IACjC,IAAI,CAAC9B,SAAU,CAAC6B,KAAK,CAACC,IAAI,CAAC,CAACM,IAAI,CAC9B,MAAK;MACH1B,GAAG,CAAC,WAAW,CAAC;MAChByB,QAAQ,EAAE;IACZ,CAAC,EACAE,GAAG,IAAI;MACN3B,GAAG,CAAC,YAAY,EAAE2B,GAAG,CAAC;MACtBF,QAAQ,CAACE,GAAG,CAAC;IACf,CAAC,CACF;IACD,OAAO,IAAI;EACb;EAEAC,GAAGA,CAAA,EAA6G;IAAA,IAA5GR,IAAI,GAAAE,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAGL,MAAM,CAACY,KAAK,CAAC,CAAC,CAAC;IAAA,IAAER,QAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAA2B,MAAM;IAAA,IAAEG,QAAA,GAAAH,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAyC,MAAK,CAAE,CAAC;IAC9GtB,GAAG,CAAC,kBAAkB,CAAC;IACvB,IAAI,CAACmB,KAAK,CAACC,IAAI,EAAEC,QAAQ,EAAGM,GAAG,IAAI;MACjC,IAAI,CAACtC,SAAU,CAACyC,KAAK,EAAE;MACvB,IAAIL,QAAQ,EAAEA,QAAQ,CAACE,GAAG,CAAC;IAC7B,CAAC,CAAC;IACF,OAAO,IAAI;EACb;EAEAI,OAAOA,CAACC,MAAc;IACpBhC,GAAG,CAAC,sBAAsB,EAAEgC,MAAM,CAAC;IACnC,IAAI,CAAC9C,SAAS,GAAG,IAAI;IACrB,OAAO,IAAI,CAAC0C,GAAG,EAAE;EACnB;EAEAK,QAAQA,CAAC/B,OAAmB;IAC1B,IAAI,IAAI,CAACd,SAAS,EAAE;MAClB;MACA,IAAI,CAACuB,IAAI,CAAC,OAAO,EAAE,qDAAqD,CAAC;MACzE;;IAEF,IAAI,CAACrB,SAAU,CAAC4C,WAAW,EAAE;IAC7B,IAAI,CAAC3C,SAAU,CAAC2C,WAAW,EAAE;IAC7B,IAAI,CAAC/C,UAAU,GAAG,IAAI;IACtB,IAAI,CAACE,SAAS,GAAG,IAAI,CAACA,SAAU,CAAC4C,QAAQ,CAAC/B,OAAO,CAAC;IAClD,IAAI,CAACZ,SAAS,GAAG,IAAI,CAACD,SAAS,CAACJ,QAAQ,CAACmB,SAAS,EAAE;IACpD,IAAI,CAACb,SAAS,GAAG,IAAI,CAACF,SAAS,CAACiB,QAAQ,CAACC,SAAS,EAAE;IACpD,IAAI,CAACF,iBAAiB,EAAE;IACxB,IAAI,CAACO,OAAO,EAAE,CAACH,KAAK,CAAEC,CAAC,IAAK,IAAI,CAACC,IAAI,CAAC,OAAO,EAAED,CAAC,CAAC,CAAC;EACpD;EAEAL,iBAAiBA,CAAA;IACf,IAAI,CAAChB,SAAU,CAAC8C,MAAM,CAACT,IAAI,CAAC,MAAK;MAC/B,IAAI,CAAC,IAAI,CAACvC,UAAU,EAAE;QACpBa,GAAG,CAAC,kBAAkB,CAAC;QACvB,IAAI,CAACX,SAAS,GAAG,IAAI;QACrB,IAAI,CAACsB,IAAI,CAAC,OAAO,CAAC;OACnB,MAAM;QACL,IAAI,CAACxB,UAAU,GAAG,KAAK;QACvB,IAAI,CAACC,SAAS,GAAG,IAAI;;IAEzB,CAAC,CAAC,CAACqB,KAAK,CAAEC,CAAC,IAAK,IAAI,CAACC,IAAI,CAAC,OAAO,EAAED,CAAC,CAAC,CAAC;EACxC;;AAGF,MAAM0B,KAAK,GAAG,KAAK;AAEnB,SAASC,IAAIA,CAACjB,IAAa;EACzB,IAAIA,IAAI,YAAYkB,UAAU,IAAIlB,IAAI,YAAYmB,WAAW,EAAE;IAC7D,MAAMC,GAAG,GAAGvB,MAAM,CAACC,IAAI,CAACE,IAAI,CAAC,CAACqB,QAAQ,CAAC,KAAK,CAAC;IAC7C,MAAMC,GAAG,GAAG,IAAIC,WAAW,EAAE,CAACC,MAAM,CAACxB,IAAI,CAAC;IAC1C,OAAO,eAAesB,GAAG,CAACG,OAAO,CAAC,KAAK,EAAE,KAAK,CAAC,eAAeL,GAAG,IAAI;GACtE,MAAM;IACL,OAAOpB,IAAI;;AAEf;AAEA,SAASpB,GAAGA,CAAA,EAAmB;EAAA,SAAA8C,IAAA,GAAAxB,SAAA,CAAAC,MAAA,EAAfwB,IAAe,OAAAC,KAAA,CAAAF,IAAA,GAAAG,IAAA,MAAAA,IAAA,GAAAH,IAAA,EAAAG,IAAA;IAAfF,IAAe,CAAAE,IAAA,IAAA3B,SAAA,CAAA2B,IAAA;EAAA;EAC7Bb,KAAK,IAAIc,OAAO,CAAClD,GAAG,CAAC,GAAG+C,IAAI,CAACI,GAAG,CAACd,IAAI,CAAC,CAAC;AACzC"},"metadata":{},"sourceType":"module","externalDependencies":[]}